#### 1. Структурирование программы
Функции, модули, классы

#### 2. Прототипы функций и стиль их описания
Прототип функции, он же называется объявлением функции состоит из трех частей

`[тип возвращаемого значения] [имя функции] ([аргументы функции]);`

Назначение прототипа функции - предварительное описании функции для компилятора.
Оно должно быть размещено до определения самой функции(тело функции). Обычно его размещают в заголовочном файле,
если предполагается его использование в других модулях компиляции или в начале модуля компиляции,
если функция будет использоваться только в нем.

Пример:

`int foo(float a, float b);`

 `int` тип возвращаемого значения
 
 `foo` имя функции
 
`a` и `b` - аргументы


Если функция не подразумевает возвращаемого значения, то тип возвращаемого значения указывается void.
Прототип функции отличается от ее определения отсутствием тела.

```C++
#include <iostream>

int sum(int a, int b); // Объявление

int main() {
    std::cout << sum(4,5) << std::endl;
    return 0;
}

int sum(int a, int b) { // Определение
    int result = 0;
    result = a + b;
    return result;
}
```

#### 3. Классы памяти и области видимости переменных в функциях
Класс памяти отвечает за размещение и дальнейшее использования переменной. По-умолчанию, переменная имеет класс `auto`,
то есть размещена в области видимости, в которой объявлена. Другими словами, это обычная локальная переменная,
существующая только внутри области видимости - внутри функции, модуля, класса. Этот класс не надо указывать, все
переменные без дополнительных модификаторов являются локальными. Важно не путать описание класса памяти `auto` и
типа переменной `auto`!

`extern` указывает на то, что переменная внешняя, то есть ее объявление находится в другом файле.

`static` указывает на то, что переменная сугубо внутренняя, доступна только внутри файла. Важной особенностью является то,
что если переменная объявлена `static` внутри функции, она просуществует все время выполнения программы.
```c++
#include <iostream>

int inc() {
    static int x = 0;
    x++;
    return x;
}

int main() {
    std::cout << inc();
    std::cout << inc();
    std::cout << inc();
    return 0;
}

``` 
Эта программа выведет 1,2,3;

```c++
#include <iostream>

int inc() {
    int x = 0;
    x++;
    return x;
}

int main() {
    std::cout << inc() << ",";
    std::cout << inc() << ",";
    std::cout << inc();
    return 0;
}
```

а если убрать слово static на экран будет выведено 1,1,1

`register` устаревший класс памяти, подсказывающий компилятору, что эту переменную следует разместить в отдельном
регистре процессора. Используется для ускорения работы программы, т.к. доступ к регистрам процессора быстрее, чем
доступ к памяти. В настоящее время компиляторы достаточно умны, чтобы разобраться с такими переменными самостоятельно.
Является только подсказкой и ни к чему в настоящее время не обязывает.

`thread_local` указывает на то, что переменная относится к потоку, в котором создана, может комбинироваться с `static`
и `extern`


#### 4. Типы возвращаемых значений
Тип возвращаемого значения не обязательно должен быть одним из встроенных. Это может быть структура, класс, в том
числе и собственные. Тип возвращаемого значения определяется при ее объявлении.

#### 5. Способы передачи аргументов в функции
Аргументы могут передаваться по значению (by value) и по ссылке (by reference).
При передаче аргументов по значению внешний объект, который передается в качестве аргумента в функцию,
не может быть изменен в этой функции. В функцию передается само значение этого объекта.
```c++
#include <iostream>

int inc(int x) {
    x++;
    return x;
}

int main() {
    int x = 0;
    std::cout << inc(x) << ",";
    std::cout << x;
    return 0;
}
``` 

Выведет 1,0, т.к. в функцию переменная была педерана по значению, другими словами была передана копия переменной, а не
сама переменная.
Стоит немного изменить функцию, добавив указание, чтобы компилятор передал переменную по ссылке:
```c++
 #include <iostream>
 
 int inc(int &x) {
     x++;
     return x;
 }
 
 int main() {
     int x = 0;
     std::cout << inc(x) << ",";
     std::cout << x;
     return 0;
 }
```
и программ выведет 1,1, так как операцию внутри фунции мы проводим не с копией переменной, а непосредственно с ней
самой. Важный практический смысл заключается в том, что если тип переменной сложный - например, класс или структура -
то при передаче переменной по значению будет создаваться ее копия, а это может быть связано с существенными накладными
расходами.

Полезно использовать `const` при передаче переменной в функцию, чтобы показать, что внутри функции переменную изменять
нельзя.

```c++
int inc(const int x) {
    x++;
    return x;
}
``` 
и компилятор выдаст ошибку `error: increment of read-only parameter ‘x’` 

#### 6. Передача массивов в качестве аргументов
Если функция принимает в качестве агрумента массив, то фактически в эту функцию передается указатель на первый элемент 
массива, остальное делает за нас компилятор. Как и в случае с указателями нам доступен адрес,
по которому мы можем менять значения.
Например, записи :
```c++
int sum(int x[], int len) {
    int sum = 0;
    for(int i = 0;i<len;i++) {
        sum += x[i];
    }
    return sum;
}
```
и
```c++
int sum(int *x, int len) {
    int sum = 0;
    for(int i = 0;i<len;i++) {
        sum += x[i];
    }
    return sum;
}
```
равнозначны.

И не забываем про слово `const`:
```c++
int sum(const int x[], const int len) {
    int sum = 0;
    for(int i = 0;i<len;i++) {
        sum += x[i];
        x[i] += sum;
    }
    return sum;
}
```
выдаст ошибку при компиляции.

#### 7. Аргументы по-умолчанию
В С++ есть возможность не указывать некоторые агрументы функции, если указано какое значение поставить на их место
в таком случае.
Например:
```c++
#include <iostream>

int sum(int x[], int len = 4) {
    int sum = 0;
    for(int i = 0;i<len;i++) {
        sum += x[i];
    }
    return sum;
}

int main() {
    int x[] = {1,2,3,4};
    std::cout << sum(x) << std::endl;
    return 0;
}

```
Если не указать значение аргумента len, будет подставлено значение 4. Стоит ли говорить, что если массив будет
размера отличного от 4, функция отработает не правильно. Поэтому этот механизм надо использовать с осторожностью.
Вот безопасный пример:
```c++
#include <iostream>

int sum(const int x[], int len, bool print = false) {
    int sum = 0;
    for(int i = 0;i<len;i++) {
        sum += x[i];
    }
    if(print) {
        std::cout << sum << std::endl;
    }
    return sum;
}

int main() {
    int x[] = {1,2,3,4};
    sum(x, 4);
    sum(x, 4, true);
    return 0;
}

```

Если для одного из параметров указано значение по-умолчанию, то следующие тоже должны иметь такие значения:
```c++
#include <iostream>

int sum(const int x[], bool print = false, int len) {
    int sum = 0;
    for(int i = 0;i<len;i++) {
        sum += x[i];
    }
    if(print) {
        std::cout << sum << std::endl;
    }
    return sum;
}

int main() {
    int x[] = {1,2,3,4};
    sum(x, 4);
    return 0;
}
```
Такая запись уже не корректна, о чем компилятор сообщит.

#### 8. Полиморфизм(перегрузка) функций


#### 9. Структуры и классы в С++
#### 10. Базовые концепции классов
#### 11. Инкапсуляция данных и методов
#### 12. Объекты, указатели на объекты и способы доступа к ним
#### 13. Конструкторы и деструкторы
#### 14. Файлы: потоковый ввод-вывод
#### 15. Открытие/закрытие файлов
#### 16. Запись в файл
#### 17. Чтений из файла
#### 18. Прямой доступ при использовании файлов
#### 19. Простой вид списков - однонаправленный линейный, использование указателей
#### 20. Базовые концепции однонаправленного линейного списка: элемент списка(описание с использованием структуры/класса), указатель на следующий элемент
#### 21. Базовые операции с однонаправленным линейным списком: создание пустого списка, удаление всего списка
#### 22. Простой вид списков - однонаправленный, линейный, использование формуляра указателей
#### 23. Основные операции с однонаправленным линейным списком: вставка элемента(варианты)
#### 24. Основные операции с однонаправленным линейным списком: удаление элемента(варианты)
#### 25. Хранение и обработка текстовой информации: представление строки с маркером
#### 26. Хранение и обработка текстовой информации: использование списка для работы с набором строк
#### 27. Факультативно: библиотека обработки символьных строк.
